# Project: Python TXT Reader (v5+)

## 1. 项目愿景与核心目标
一个基于 Tkinter 的轻量级大文本阅读器。核心痛点是：**秒开大文件、精准历史定位、支持正则章节解析、提供沉浸式阅读体验。**

## 2. 技术栈
- **语言**: Python 3.x
- **UI 库**: Tkinter (ttk)
- **核心逻辑**: 多线程解析、字节流定位、正则匹配、编码自动检测 (chardet/charset_normalizer)。

## 3. 目录结构与职责
- `main.py`: 程序入口，初始化根窗口和 App 实例。
- `ui/app.py`: UI 逻辑层。负责事件绑定、界面渲染、与 Parser 的异步交互、状态栏更新。
- `core/txt_parser.py`: 核心逻辑层。负责大文件的二进制读取、正则解析章节、编码检测、按需提取内容。
- `utils/config.py`: 配置管理类。负责 `reader_settings.json` 的读写，管理全局配置和每本书的历史存档。
- `ui/styles.py`: 样式定义。存储主题颜色、字体配置、默认正则表达式。

## 4. 核心机制 (关键细节 - 不可误删)
### A. 异步解析流程
1. `UI` 调用 `Parser.scan(rule)`。
2. `Parser` 开启独立线程遍历字节流，通过 `re.finditer` 寻找章节。
3. `Parser` 每解析到一定阶段或完成时，通过 `callback` 函数（配合 `root.after`）将数据同步回主线程 UI。
4. **注意**: UI 必须在解析未完成时也能显示基础内容（通常是第0章）。

### B. 定位与存档逻辑 (目前的重点)
- **双重定位**: 
    1. `ch_idx`: 章节索引（易受正则变化影响）。
    2. `byte_pos`: 章节在文件中的绝对字节偏移量（最稳定，用于校准）。
    3. `offset`: 滚动条在 `Text` 控件中的百分比位置 (0.0 - 1.0)。
- **保存时机**: 切换文件时、关闭程序时、手动保存编辑时。

### C. UI 更新陷阱
- `Tkinter` 非线程安全。所有从 `Parser` 线程回传的更新必须通过 `root.after` 调度到主线程执行。
- `Text` 控件在内容未完全渲染完成时，调用 `yview_moveto` 会失效，需要微小延迟。

## 5. 数据 Schema (`reader_settings.json`)
```json
{
  "font_size": 18,
  "theme": "warm",
  "last_file": "path/to/book.txt",
  "files": {
    "absolute_path_to_file": {
      "ch_idx": 10,
      "byte_pos": 1048576,
      "offset": 0.45,
      "total_time": 3600
    }
  }
}
```

---
## 6. 当前已知痛点（已经解决，注意不要引入）
- 历史位置恢复的可靠性（解析线程与渲染的时序冲突）。
- 目录定位与正文渲染的同步。
- 计时器在文件未加载时的展示逻辑。

---

## 如何在对话中使用这个表示？

当你开启一个新对话或需要 AI 进行大改动时，你可以这样表述：

> **User:** "我要对我的 Python 阅读器项目进行优化。为了让你理解全局，请先阅读我提供的 `AGENT.MD`（项目结构和核心逻辑说明）。
> 
> [粘贴 AGENT.MD 的内容]
> 
> 现在我遇到的具体问题是：[描述问题，例如：切换文件后正文没显示]。
> 
> 相关的代码片段如下：
> [粘贴 UI 加载部分的代码]"

### 为什么这样做有效？

1.  **建立心理模型**：AI 不再是盲人摸象，它知道你有一个 `Parser` 类，知道你是通过字节定位的。
2.  **保护关键细节**：通过在 `AGENT.MD` 中明确“不可误删”的机制（如 `root.after` 的必要性），可以防止 AI 给出看似优雅但实际会导致程序崩溃（多线程安全问题）的代码。
3.  **减少 Token 消耗**：你不需要每次都发所有代码，只需发相关的模块，AI 能自动根据蓝图推断出未提供的部分是如何工作的